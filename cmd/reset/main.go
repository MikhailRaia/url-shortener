package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// FilterConfig contains configuration for directory filtering during package scanning.
type FilterConfig struct {
	// ExcludePatterns is a list of patterns to exclude from scanning.
	ExcludePatterns []string
}

const fileTemplate = `// Code generated by cmd/reset - DO NOT EDIT.

package {{ .PackageName }}

{{ range .Methods }}{{ . }}
{{ end }}`

const methodTemplate = `func (r *{{ .StructName }}) Reset() {
	if r == nil {
		return
	}

{{ range .FieldResets }}{{ . }}{{ end }}}
`

func main() {
	rootDir := flag.String("dir", ".", "root directory to scan")
	excludeStr := flag.String("exclude", "vendor,node_modules,.* testdata", "comma-separated patterns to exclude")
	flag.Parse()

	var patterns []string
	if *excludeStr != "" {
		patterns = strings.Split(*excludeStr, ",")
		for i := range patterns {
			patterns[i] = strings.TrimSpace(patterns[i])
		}
	}

	config := FilterConfig{
		ExcludePatterns: patterns,
	}

	if err := generateResetMethods(*rootDir, config); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func generateResetMethods(rootDir string, config FilterConfig) error {
	packages := make(map[string]*PackageResets)

	err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !info.IsDir() || shouldSkip(path, config) {
			return nil
		}

		pkg, err := scanPackage(path)
		if err != nil {
			return nil
		}

		if pkg != nil && len(pkg.Structs) > 0 {
			packages[path] = pkg
		}

		return nil
	})

	if err != nil {
		return err
	}

	for pkgPath, pkg := range packages {
		if err := writeResetFile(pkgPath, pkg); err != nil {
			return fmt.Errorf("failed to write reset file for %s: %w", pkgPath, err)
		}
	}

	if len(packages) > 0 {
		fmt.Printf("Generated reset methods for %d packages\n", len(packages))
	}

	return nil
}

func shouldSkip(path string, config FilterConfig) bool {
	name := filepath.Base(path)
	for _, pattern := range config.ExcludePatterns {
		if matchPattern(name, path, pattern) {
			return true
		}
	}
	return false
}

func matchPattern(dirName, fullPath, pattern string) bool {
	if pattern == "" {
		return false
	}

	pattern = strings.TrimSpace(pattern)

	if strings.HasPrefix(pattern, ".") {
		return strings.HasPrefix(dirName, pattern)
	}

	if strings.Contains(pattern, "/") || strings.Contains(pattern, "\\") {
		return strings.Contains(fullPath, pattern)
	}

	return dirName == pattern
}

// PackageResets represents a Go package and the structures within it that need Reset() methods generated.
type PackageResets struct {
	// Name is the package name.
	Name string
	// Path is the directory path of the package.
	Path string
	// Structs is the list of structures that need Reset() methods.
	Structs []StructReset
}

// StructReset represents a structure for which a Reset() method should be generated.
type StructReset struct {
	// Name is the name of the structure.
	Name string
	// Fields is the list of fields in the structure.
	Fields []FieldReset
}

// FieldReset represents a field of a structure that needs to be reset.
type FieldReset struct {
	// Name is the name of the field.
	Name string
	// Type is the AST expression representing the field's type.
	Type ast.Expr
}

func scanPackage(pkgPath string) (*PackageResets, error) {
	entries, err := os.ReadDir(pkgPath)
	if err != nil {
		return nil, err
	}

	fset := token.NewFileSet()
	var files []*ast.File
	var pkgName string

	for _, entry := range entries {
		if entry.IsDir() || strings.HasSuffix(entry.Name(), "_test.go") {
			continue
		}

		if !strings.HasSuffix(entry.Name(), ".go") {
			continue
		}

		filePath := filepath.Join(pkgPath, entry.Name())
		f, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
		if err != nil {
			continue
		}

		if pkgName == "" {
			pkgName = f.Name.Name
		}

		files = append(files, f)
	}

	if len(files) == 0 {
		return nil, nil
	}

	result := &PackageResets{
		Name: pkgName,
		Path: pkgPath,
	}

	for _, f := range files {
		for _, decl := range f.Decls {
			typeDecl, ok := decl.(*ast.GenDecl)
			if !ok || typeDecl.Tok != token.TYPE {
				continue
			}

			if typeDecl.Doc != nil && hasGenerateResetComment(typeDecl.Doc) {
				for _, spec := range typeDecl.Specs {
					typeSpec := spec.(*ast.TypeSpec)
					structType, ok := typeSpec.Type.(*ast.StructType)
					if !ok {
						continue
					}

					sr := StructReset{
						Name:   typeSpec.Name.Name,
						Fields: extractFields(structType),
					}
					result.Structs = append(result.Structs, sr)
				}
			}
		}
	}

	return result, nil
}

func hasGenerateResetComment(doc *ast.CommentGroup) bool {
	if doc == nil {
		return false
	}

	for _, comment := range doc.List {
		if strings.Contains(comment.Text, "generate:reset") {
			return true
		}
	}

	return false
}

func extractFields(structType *ast.StructType) []FieldReset {
	var fields []FieldReset

	if structType.Fields == nil {
		return fields
	}

	for _, field := range structType.Fields.List {
		if len(field.Names) == 0 {
			continue
		}

		for _, name := range field.Names {
			if !ast.IsExported(name.Name) {
				continue
			}

			fields = append(fields, FieldReset{
				Name: name.Name,
				Type: field.Type,
			})
		}
	}

	return fields
}

func writeResetFile(pkgPath string, pkg *PackageResets) error {
	resetFilePath := filepath.Join(pkgPath, "reset.gen.go")

	code := generateCode(pkg)

	return os.WriteFile(resetFilePath, []byte(code), 0644)
}

func generateCode(pkg *PackageResets) string {
	var methods []string
	for _, sr := range pkg.Structs {
		methods = append(methods, generateResetMethod(sr))
	}

	tmpl, err := template.New("file").Parse(fileTemplate)
	if err != nil {
		return ""
	}

	type FileData struct {
		PackageName string
		Methods     []string
	}

	data := FileData{
		PackageName: pkg.Name,
		Methods:     methods,
	}

	var buf strings.Builder
	if err := tmpl.Execute(&buf, data); err != nil {
		return ""
	}

	return buf.String()
}

func generateResetMethod(sr StructReset) string {
	var fieldResets []string
	for _, field := range sr.Fields {
		fieldResets = append(fieldResets, generateFieldReset(field))
	}

	tmpl, err := template.New("method").Parse(methodTemplate)
	if err != nil {
		return ""
	}

	type MethodData struct {
		StructName  string
		FieldResets []string
	}

	data := MethodData{
		StructName:  sr.Name,
		FieldResets: fieldResets,
	}

	var buf strings.Builder
	if err := tmpl.Execute(&buf, data); err != nil {
		return ""
	}

	return buf.String()
}

func generateFieldReset(field FieldReset) string {
	return generateTypeReset("r."+field.Name, field.Type, "")
}

func generateTypeReset(varName string, expr ast.Expr, indent string) string {
	switch t := expr.(type) {
	case *ast.Ident:
		switch t.Name {
		case "string":
			return indent + varName + " = \"\"\n"
		case "bool":
			return indent + varName + " = false\n"
		case "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "float32", "float64":
			return indent + varName + " = 0\n"
		case "byte", "rune":
			return indent + varName + " = 0\n"
		default:
			return indent + "if resetter, ok := " + varName + ".(interface{ Reset() }); ok && " + varName + " != nil {\n" +
				indent + "\tresetter.Reset()\n" +
				indent + "}\n"
		}

	case *ast.ArrayType:
		if t.Len == nil {
			return indent + varName + " = " + varName + "[:0]\n"
		}
		return indent + varName + " = " + getZeroValue(t.Elt) + "\n"

	case *ast.MapType:
		return indent + "clear(" + varName + ")\n"

	case *ast.StarExpr:
		elemType := t.X
		switch et := elemType.(type) {
		case *ast.Ident:
			switch et.Name {
			case "string":
				return indent + "if " + varName + " != nil {\n" +
					indent + "\t*" + varName + " = \"\"\n" +
					indent + "}\n"
			case "bool":
				return indent + "if " + varName + " != nil {\n" +
					indent + "\t*" + varName + " = false\n" +
					indent + "}\n"
			case "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "float32", "float64", "byte", "rune":
				return indent + "if " + varName + " != nil {\n" +
					indent + "\t*" + varName + " = 0\n" +
					indent + "}\n"
			default:
				return indent + "if resetter, ok := (*" + varName + ").(interface{ Reset() }); ok && " + varName + " != nil {\n" +
					indent + "\tresetter.Reset()\n" +
					indent + "}\n"
			}
		default:
			return indent + "if " + varName + " != nil {\n" +
				indent + generateTypeReset("(*"+varName+")", elemType, indent+"\t") +
				indent + "}\n"
		}

	default:
		return ""
	}
}

func getZeroValue(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		switch t.Name {
		case "string":
			return "\"\""
		case "bool":
			return "false"
		case "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "float32", "float64", "byte", "rune":
			return "0"
		default:
			return t.Name + "{}"
		}
	default:
		return "nil"
	}
}
