package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	rootDir := "."
	if err := generateResetMethods(rootDir); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func generateResetMethods(rootDir string) error {
	packages := make(map[string]*PackageResets)

	err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !info.IsDir() || shouldSkip(path) {
			return nil
		}

		pkg, err := scanPackage(path)
		if err != nil {
			return nil
		}

		if pkg != nil && len(pkg.Structs) > 0 {
			packages[path] = pkg
		}

		return nil
	})

	if err != nil {
		return err
	}

	for pkgPath, pkg := range packages {
		if err := writeResetFile(pkgPath, pkg); err != nil {
			return fmt.Errorf("failed to write reset file for %s: %w", pkgPath, err)
		}
	}

	if len(packages) > 0 {
		fmt.Printf("Generated reset methods for %d packages\n", len(packages))
	}

	return nil
}

func shouldSkip(path string) bool {
	name := filepath.Base(path)
	return strings.HasPrefix(name, ".") ||
		name == "vendor" ||
		name == "node_modules" ||
		strings.Contains(path, "/testdata/") ||
		strings.Contains(path, "\\testdata\\")
}

// PackageResets represents a Go package and the structures within it that need Reset() methods generated.
type PackageResets struct {
	Name    string
	Path    string
	Structs []StructReset
}

// StructReset represents a structure for which a Reset() method should be generated.
type StructReset struct {
	Name   string
	Fields []FieldReset
}

// FieldReset represents a field of a structure that needs to be reset.
type FieldReset struct {
	Name string
	Type ast.Expr
}

func scanPackage(pkgPath string) (*PackageResets, error) {
	entries, err := os.ReadDir(pkgPath)
	if err != nil {
		return nil, err
	}

	fset := token.NewFileSet()
	var files []*ast.File
	var pkgName string

	for _, entry := range entries {
		if entry.IsDir() || strings.HasSuffix(entry.Name(), "_test.go") {
			continue
		}

		if !strings.HasSuffix(entry.Name(), ".go") {
			continue
		}

		filePath := filepath.Join(pkgPath, entry.Name())
		f, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
		if err != nil {
			continue
		}

		if pkgName == "" {
			pkgName = f.Name.Name
		}

		files = append(files, f)
	}

	if len(files) == 0 {
		return nil, nil
	}

	result := &PackageResets{
		Name: pkgName,
		Path: pkgPath,
	}

	for _, f := range files {
		for _, decl := range f.Decls {
			typeDecl, ok := decl.(*ast.GenDecl)
			if !ok || typeDecl.Tok != token.TYPE {
				continue
			}

			if typeDecl.Doc != nil && hasGenerateResetComment(typeDecl.Doc) {
				for _, spec := range typeDecl.Specs {
					typeSpec := spec.(*ast.TypeSpec)
					structType, ok := typeSpec.Type.(*ast.StructType)
					if !ok {
						continue
					}

					sr := StructReset{
						Name:   typeSpec.Name.Name,
						Fields: extractFields(structType),
					}
					result.Structs = append(result.Structs, sr)
				}
			}
		}
	}

	return result, nil
}

func hasGenerateResetComment(doc *ast.CommentGroup) bool {
	if doc == nil {
		return false
	}

	for _, comment := range doc.List {
		if strings.Contains(comment.Text, "generate:reset") {
			return true
		}
	}

	return false
}

func extractFields(structType *ast.StructType) []FieldReset {
	var fields []FieldReset

	if structType.Fields == nil {
		return fields
	}

	for _, field := range structType.Fields.List {
		if len(field.Names) == 0 {
			continue
		}

		for _, name := range field.Names {
			if !ast.IsExported(name.Name) {
				continue
			}

			fields = append(fields, FieldReset{
				Name: name.Name,
				Type: field.Type,
			})
		}
	}

	return fields
}

func writeResetFile(pkgPath string, pkg *PackageResets) error {
	resetFilePath := filepath.Join(pkgPath, "reset.gen.go")

	code := generateCode(pkg)

	return os.WriteFile(resetFilePath, []byte(code), 0644)
}

func generateCode(pkg *PackageResets) string {
	var sb strings.Builder

	sb.WriteString("// Code generated by cmd/reset - DO NOT EDIT.\n\n")
	sb.WriteString("package " + pkg.Name + "\n\n")

	for _, sr := range pkg.Structs {
		sb.WriteString(generateResetMethod(sr))
		sb.WriteString("\n")
	}

	return sb.String()
}

func generateResetMethod(sr StructReset) string {
	var sb strings.Builder

	sb.WriteString("func (r *" + sr.Name + ") Reset() {\n")
	sb.WriteString("\tif r == nil {\n")
	sb.WriteString("\t\treturn\n")
	sb.WriteString("\t}\n\n")

	for _, field := range sr.Fields {
		sb.WriteString(generateFieldReset(field))
	}

	sb.WriteString("}\n")

	return sb.String()
}

func generateFieldReset(field FieldReset) string {
	return generateTypeReset("r."+field.Name, field.Type, "")
}

func generateTypeReset(varName string, expr ast.Expr, indent string) string {
	switch t := expr.(type) {
	case *ast.Ident:
		switch t.Name {
		case "string":
			return indent + varName + " = \"\"\n"
		case "bool":
			return indent + varName + " = false\n"
		case "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "float32", "float64":
			return indent + varName + " = 0\n"
		case "byte", "rune":
			return indent + varName + " = 0\n"
		default:
			return indent + "if resetter, ok := " + varName + ".(interface{ Reset() }); ok && " + varName + " != nil {\n" +
				indent + "\tresetter.Reset()\n" +
				indent + "}\n"
		}

	case *ast.ArrayType:
		if t.Len == nil {
			return indent + varName + " = " + varName + "[:0]\n"
		}
		return indent + varName + " = " + getZeroValue(t.Elt) + "\n"

	case *ast.MapType:
		return indent + "clear(" + varName + ")\n"

	case *ast.StarExpr:
		elemType := t.X
		switch et := elemType.(type) {
		case *ast.Ident:
			switch et.Name {
			case "string":
				return indent + "if " + varName + " != nil {\n" +
					indent + "\t*" + varName + " = \"\"\n" +
					indent + "}\n"
			case "bool":
				return indent + "if " + varName + " != nil {\n" +
					indent + "\t*" + varName + " = false\n" +
					indent + "}\n"
			case "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "float32", "float64", "byte", "rune":
				return indent + "if " + varName + " != nil {\n" +
					indent + "\t*" + varName + " = 0\n" +
					indent + "}\n"
			default:
				return indent + "if resetter, ok := (*" + varName + ").(interface{ Reset() }); ok && " + varName + " != nil {\n" +
					indent + "\tresetter.Reset()\n" +
					indent + "}\n"
			}
		default:
			return indent + "if " + varName + " != nil {\n" +
				indent + generateTypeReset("(*"+varName+")", elemType, indent+"\t") +
				indent + "}\n"
		}

	default:
		return ""
	}
}

func getZeroValue(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		switch t.Name {
		case "string":
			return "\"\""
		case "bool":
			return "false"
		case "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "float32", "float64", "byte", "rune":
			return "0"
		default:
			return t.Name + "{}"
		}
	default:
		return "nil"
	}
}
